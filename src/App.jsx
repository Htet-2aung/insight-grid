import React, { useState, useEffect, useRef } from 'react';
import { createClient } from '@supabase/supabase-js';
import { Loader, BarChart2, Clock, Users, Search, User, LogOut, PlusCircle, UploadCloud, Trash2, X, ArrowLeft, FileText, TestTube2, MessageSquare, Send, Globe, Edit, Code, Save, XCircle } from 'lucide-react';
import './App.css'; 
// Assuming NotebookRender.js exists in the same directory or is correctly pathed.
// If not, these components will need to be created or imported from their actual location.
const MarkdownRenderer = ({ content }) => <div dangerouslySetInnerHTML={{ __html: content }} />;
const CodeOutputRenderer = ({ output }) => <pre><code>{JSON.stringify(output, null, 2)}</code></pre>;
const JupyterNotebookContentViewer = ({ notebookJson }) => {
    if (!notebookJson || !notebookJson.cells) return <div>No notebook content to display.</div>;
    return (
        <div className="notebook-viewer">
            {notebookJson.cells.map((cell, index) => (
                <div key={index} className={`notebook-cell ${cell.cell_type}`}>
                    {cell.cell_type === 'markdown' && <MarkdownRenderer content={cell.source.join('')} />}
                    {cell.cell_type === 'code' && (
                        <>
                            <pre className="code-cell"><code>{cell.source.join('')}</code></pre>
                            <div className="output-cell">
                                {(cell.outputs || []).map((output, out_index) => (
                                    <CodeOutputRenderer key={out_index} output={output} />
                                ))}
                            </div>
                        </>
                    )}
                </div>
            ))}
        </div>
    );
};


// --- SUPABASE SETUP ---
const supabaseUrl = 'https://amepwiogiucmuqynxgrb.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFtZXB3aW9naXVjbXVxeW54Z3JiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI4MjQ2OTgsImV4cCI6MjA2ODQwMDY5OH0.-y2hIxFXch3nW8WnXRp0iPEKRUov7jAhczrbmK9o8-o';
const supabase = createClient(supabaseUrl, supabaseKey);

// --- NOTEBOOK ANALYSIS LOGIC (with fallback) ---
const localNotebookAnalysis = (notebookContent) => {
    try {
        const notebook = JSON.parse(notebookContent);
        let title = "Untitled Project";
        let description = "Locally analyzed notebook. Summary could not be generated by AI.";
        const tags = new Set();
        let accuracy = null;

        const firstMarkdownCell = notebook.cells.find(cell => cell.cell_type === 'markdown');
        if (firstMarkdownCell) {
            const sourceText = firstMarkdownCell.source.join('');
            const titleMatch = sourceText.match(/^#\s+(.*)/);
            title = titleMatch ? titleMatch[1] : 'Untitled Project';
        }

        notebook.cells.forEach(cell => {
            if (cell.cell_type === 'code') {
                const code = cell.source.join('\n');
                if (code.includes('sklearn')) tags.add('Scikit-learn');
                if (code.includes('pandas')) tags.add('Pandas');
                if (code.includes('tensorflow')) tags.add('TensorFlow');
                if (code.includes('torch')) tags.add('PyTorch');
                if (cell.outputs && Array.isArray(cell.outputs)) {
                    cell.outputs.forEach(output => {
                        if (output.name === 'stdout' || output.output_type === 'stream') {
                            const outputText = Array.isArray(output.text) ? output.text.join('\n') : '';
                            const accuracyMatch = outputText.match(/Accuracy:\s*(\d\.\d+)/i);
                            if (accuracyMatch && accuracyMatch[1]) {
                                accuracy = parseFloat(accuracyMatch[1]);
                            }
                        }
                    });
                }
            }
        });

        return {
            title,
            description,
            methodology: "Analysis performed by local parser.",
            tags: Array.from(tags),
            visualizations: ["N/A"],
            accuracy: accuracy,
        };
    } catch (e) {
        console.error("Local parsing failed:", e);
        return null;
    }
};

const cleanNotebookForApi = (notebookContent) => {
    try {
        const notebook = JSON.parse(notebookContent);
        const cleanedCells = notebook.cells.map(cell => {
            if (cell.cell_type === 'code') {
                const cleanedOutputs = (cell.outputs || []).map(output => {
                    if (output.data && output.data['image/png']) {
                        return { ...output, data: { 'text/plain': '[Image Output Hidden]' } };
                    }
                    return output;
                });
                return { ...cell, outputs: cleanedOutputs };
            }
            return cell;
        });
        return JSON.stringify({ ...notebook, cells: cleanedCells });
    } catch (e) {
        console.error("Error cleaning notebook:", e);
        return notebookContent; // Return original if cleaning fails
    }
};

const analyzeNotebookWithLLM = async (rawNotebookContent) => {
    const apiKey = ""; // Use your Gemini API key if required
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

    try {
        const cleanedNotebookContent = cleanNotebookForApi(rawNotebookContent);
        const prompt = `Analyze the following Jupyter notebook JSON and return a structured JSON summary with fields: "title", "description", "methodology", "tags" (array of strings), "visualizations" (array of strings describing charts), and "accuracy" (a number between 0 and 1, or null if not found). Notebook Content: ${cleanedNotebookContent}`;
        const schema = {
            type: "OBJECT",
            properties: {
                "title": { "type": "STRING" },
                "description": { "type": "STRING" },
                "methodology": { "type": "STRING" },
                "tags": { "type": "ARRAY", "items": { "type": "STRING" } },
                "visualizations": { "type": "ARRAY", "items": { "type": "STRING" } },
                "accuracy": { "type": "NUMBER" }
            },
            required: ["title", "description", "methodology", "tags", "visualizations"]
        };
        const payload = {
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: { responseMimeType: "application/json", responseSchema: schema },
        };

        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) throw new Error(`API request failed with status ${response.status}`);

        const result = await response.json();
        if (!result.candidates || !result.candidates[0].content.parts[0].text) {
             throw new Error("Invalid response structure from API");
        }
        const llmResponse = JSON.parse(result.candidates[0].content.parts[0].text);
        return {
            title: llmResponse.title || "Untitled",
            description: llmResponse.description || "No description provided.",
            methodology: llmResponse.methodology || "No methodology provided.",
            tags: llmResponse.tags || [],
            visualizations: llmResponse.visualizations || [],
            accuracy: llmResponse.accuracy,
        };
    } catch (error) {
        console.warn(`AI analysis failed: ${error.message}. Falling back to local analysis.`);
        return localNotebookAnalysis(rawNotebookContent);
    }
};


// --- UI Components ---

const LoadingSpinner = () => (
    <div className="loading-spinner-overlay">
        <Loader className="animate-spin" size={48} color="var(--primary-color)" />
    </div>
);

const Badge = ({ children, className }) => <span className={`badge ${className || ''}`}>{children}</span>;

function AppHeader({ onNavigate, user }) {
    return (
        <header className="app-header">
            <div className="logo" onClick={() => onNavigate('dashboard')}>
                <BarChart2 size={28} />
                <h1>Insight Grid</h1>
            </div>
            <nav className="main-nav">
                <button onClick={() => onNavigate('timeline')}><Clock size={16} /> Timeline</button>
                <button onClick={() => onNavigate('users')}><Users size={16} /> Discover</button>
                <button onClick={() => onNavigate('search')}><Search size={16} /> Search</button>
                <button onClick={() => onNavigate('profile', user.id)}><User size={16} /> My Profile</button>
                <button onClick={() => supabase.auth.signOut()}><LogOut size={16} /> Logout</button>
            </nav>
        </header>
    );
}

const AuthComponent = ({ setError, error }) => {
    const [email, setEmail] = React.useState('');
    const [password, setPassword] = React.useState('');
    const [isLogin, setIsLogin] = React.useState(true);
    const [loading, setLoading] = React.useState(false);

    const handleAuth = async (e) => {
        e.preventDefault();
        setLoading(true);
        setError('');
        const { error } = isLogin
            ? await supabase.auth.signInWithPassword({ email, password })
            : await supabase.auth.signUp({ email, password });

        if (error) setError(error.message);
        setLoading(false);
    };

    return (
        <div className="auth-container">
            <div className="auth-form-wrapper">
                <div className="logo">
                    <BarChart2 size={40} />
                </div>
                <h2 className="auth-title">Welcome to Insight Grid</h2>
                <p className="auth-subtitle">Your space for data science showcases.</p>
                <form onSubmit={handleAuth}>
                    <input type="email" placeholder="Email" value={email} onChange={(e) => setEmail(e.target.value)} required className="auth-input" />
                    <input type="password" placeholder="Password" value={password} onChange={(e) => setPassword(e.target.value)} required className="auth-input" />
                    <button type="submit" disabled={loading} className="auth-button">{loading ? 'Loading...' : (isLogin ? 'Log In' : 'Sign Up')}</button>
                    {error && <p className="auth-error">{error}</p>}
                </form>
                <button onClick={() => setIsLogin(!isLogin)} className="auth-toggle">{isLogin ? 'Need an account? Sign Up' : 'Have an account? Log In'}</button>
            </div>
        </div>
    );
};

const ProjectCard = ({ project, onClick, onDelete }) => {
    const handleDelete = onDelete ? (e) => {
        e.stopPropagation();
        if (window.confirm('Are you sure you want to delete this project?')) {
            onDelete(project.id);
        }
    } : null;

    return (
        <div className="project-card" onClick={onClick}>
            <div className="project-card-header">
                <h3 className="project-card-title">{project.title}</h3>
                {onDelete && <button onClick={handleDelete} className="delete-button"><Trash2 size={16} /></button>}
            </div>
            <p className="project-card-description">{project.description?.substring(0, 100)}{project.description?.length > 100 ? '...' : ''}</p>
            <div className="tag-container">{(project.tags || []).map(tag => <Badge key={tag}>{tag}</Badge>)}</div>
            {project.accuracy != null && (<div className="project-card-accuracy"><strong>Accuracy:</strong> {(project.accuracy * 100).toFixed(2)}%</div>)}
        </div>
    );
};

const AddProjectModal = ({ isOpen, onClose, onAddProject }) => {
    const [title, setTitle] = React.useState('');
    const [description, setDescription] = React.useState('');
    const [methodology, setMethodology] = React.useState('');
    const [accuracy, setAccuracy] = React.useState('');
    const [tags, setTags] = React.useState('');
    const [loading, setLoading] = React.useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setLoading(true);
        const projectData = {
            title, description, methodology,
            accuracy: accuracy ? parseFloat(accuracy) : null,
            tags: tags.split(',').map(tag => tag.trim()).filter(t => t),
            visualizations: []
        };
        await onAddProject(projectData);
        setLoading(false);
        onClose();
    };

    if (!isOpen) return null;

    return (
        <div className="modal-overlay">
            <div className="modal-content">
                <form onSubmit={handleSubmit}>
                    <div className="modal-header"><h3>Add New Project</h3><button type="button" onClick={onClose} className="close-button"><X size={20} /></button></div>
                    <div className="modal-body">
                        <input placeholder="Title" value={title} onChange={e => setTitle(e.target.value)} required />
                        <textarea placeholder="Description" value={description} onChange={e => setDescription(e.target.value)} required />
                        <textarea placeholder="Methodology" value={methodology} onChange={e => setMethodology(e.target.value)} />
                        <input type="number" step="0.01" min="0" max="1" placeholder="Accuracy (e.g., 0.96)" value={accuracy} onChange={e => setAccuracy(e.target.value)} />
                        <input placeholder="Tags (comma-separated)" value={tags} onChange={e => setTags(e.target.value)} />
                    </div>
                    <div className="modal-footer">
                        <button type="button" onClick={onClose} className="button-secondary">Cancel</button>
                        <button type="submit" disabled={loading} className="button-primary">{loading ? 'Adding...' : 'Add Project'}</button>
                    </div>
                </form>
            </div>
        </div>
    );
};

const Dashboard = ({ user, onSelectProject, onNavigate }) => {
    const [projects, setProjects] = React.useState([]);
    const [loading, setLoading] = React.useState(true);
    const [isAnalyzing, setIsAnalyzing] = React.useState(false);
    const [isModalOpen, setIsModalOpen] = React.useState(false);
    const fileInputRef = React.useRef(null);

    React.useEffect(() => { fetchProjects(); }, []);

    const fetchProjects = async () => {
        setLoading(true);
        const { data, error } = await supabase.from('projects').select('*').eq('user_id', user.id).order('created_at', { ascending: false });
        if (error) console.error('Error fetching projects:', error);
        else setProjects(data);
        setLoading(false);
    };

    const addProject = async (projectData, rawNotebookContent = null) => {
        const { data, error } = await supabase.from('projects').insert([{
            ...projectData,
            user_id: user.id,
            notebook_content: rawNotebookContent ? JSON.parse(rawNotebookContent) : null
        }]).select();
        if (error) {
            alert('Error adding project: ' + error.message);
        } else if (data) {
            setProjects([data[0], ...projects]);
        }
    };

    const deleteProject = async (projectId) => {
        const { error } = await supabase.from('projects').delete().eq('id', projectId);
        if (error) alert('Error deleting project: ' + error.message);
        else setProjects(projects.filter(p => p.id !== projectId));
    };

    const handleFileUpload = async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        setIsAnalyzing(true);
        const reader = new FileReader();
        reader.onload = async (e) => {
            const rawContent = e.target.result;
            try {
                JSON.parse(rawContent);
            } catch (parseError) {
                alert("The uploaded file is not a valid JSON .ipynb file.");
                setIsAnalyzing(false);
                return;
            }
            const analyzedData = await analyzeNotebookWithLLM(rawContent);
            if (analyzedData) {
                await addProject(analyzedData, rawContent);
            } else {
                alert("Failed to analyze notebook.");
            }
            setIsAnalyzing(false);
        };
        reader.readAsText(file);
        event.target.value = null;
    };

    return (
        <>
            <AppHeader onNavigate={onNavigate} user={user} />
            <div className="page-container">
                <div className="dashboard-header">
                    <div className="welcome-message">
                        <h2>Welcome back, {user.email.split('@')[0]}!</h2>
                        <p>Here's an overview of your projects.</p>
                    </div>
                    <div className="dashboard-stats">
                        <div className="stat-card"><h3>{projects.length}</h3><p>Total Projects</p></div>
                        <div className="stat-card"><h3>{projects.length > 0 && projects.some(p => p.accuracy) ? `${(projects.reduce((acc, p) => acc + (p.accuracy || 0), 0) / projects.filter(p => p.accuracy).length * 100).toFixed(1)}%` : 'N/A'}</h3><p>Avg. Accuracy</p></div>
                    </div>
                </div>
                <div className="dashboard-actions">
                    <button onClick={() => setIsModalOpen(true)} className="action-button"><PlusCircle size={16} /> Add Manually</button>
                    <input type="file" ref={fileInputRef} onChange={handleFileUpload} style={{ display: 'none' }} accept=".ipynb" />
                    <button onClick={() => fileInputRef.current.click()} className="action-button" disabled={isAnalyzing}>
                        {isAnalyzing ? <><Loader size={16} className="animate-spin" /> Analyzing...</> : <><UploadCloud size={16} /> Analyze Notebook</>}
                    </button>
                </div>
                <main className="projects-grid">
                    {loading ? <p>Loading projects...</p> : projects.length > 0 ? projects.map(project => (
                        <ProjectCard key={project.id} project={project} onClick={() => onSelectProject(project.id)} onDelete={deleteProject} />
                    )) : <p>No projects yet. Add one manually or analyze a notebook!</p>}
                </main>
                <AddProjectModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} onAddProject={addProject} />
            </div>
        </>
    );
};

const ProjectDetailPage = ({ projectId, onNavigate, user }) => {
    const [project, setProject] = useState(null);
    const [author, setAuthor] = useState(null);
    const [loading, setLoading] = useState(true);
    const [isEditing, setIsEditing] = useState(false);
    const [editableProject, setEditableProject] = useState({});
    const [isSaving, setIsSaving] = useState(false);

    useEffect(() => {
        const fetchProjectData = async () => {
            setLoading(true);
            const { data: projectData, error: projectError } = await supabase.from('projects').select('*, profiles (id, username)').eq('id', projectId).single();
            if (projectError) {
                console.error("Error fetching project:", projectError);
            } else {
                setProject(projectData);
                setAuthor(projectData.profiles);
                setEditableProject({
                    title: projectData.title,
                    description: projectData.description,
                    methodology: projectData.methodology,
                    tags: (projectData.tags || []).join(', ')
                });
            }
            setLoading(false);
        };
        fetchProjectData();
    }, [projectId]);

    const handleUpdateProject = async () => {
        setIsSaving(true);
        const { data, error } = await supabase
            .from('projects')
            .update({
                title: editableProject.title,
                description: editableProject.description,
                methodology: editableProject.methodology,
                tags: editableProject.tags.split(',').map(t => t.trim()).filter(Boolean)
            })
            .eq('id', projectId)
            .select('*, profiles (id, username)') // Re-fetch with profile info
            .single();

        if (error) {
            alert('Error updating project: ' + error.message);
        } else {
            setProject(data);
            setAuthor(data.profiles);
            setIsEditing(false);
        }
        setIsSaving(false);
    };

    const handleInputChange = (e) => {
        const { name, value } = e.target;
        setEditableProject(prev => ({ ...prev, [name]: value }));
    };

    if (loading) return <LoadingSpinner />;
    if (!project) return <div>Project not found.</div>;

    const isOwner = user.id === project.user_id;

    return (
        <>
            <AppHeader onNavigate={onNavigate} user={user} />
            <div className="page-container">
                <button onClick={() => onNavigate('dashboard')} className="back-button"><ArrowLeft size={16} /> Back to Dashboard</button>
                <div className="project-detail-header">
                    {isEditing ? (
                        <input name="title" value={editableProject.title} onChange={handleInputChange} className="title-input" />
                    ) : (
                        <h1>{project.title}</h1>
                    )}
                    {isOwner && !isEditing && <button onClick={() => setIsEditing(true)} className="action-button"><Edit size={16} /> Edit Project</button>}
                </div>
                <p className="author-info">By: {author?.username || 'Unknown Author'}</p>
                
                {isEditing ? (
                    <div className="edit-form">
                        <label>Description</label>
                        <textarea name="description" value={editableProject.description} onChange={handleInputChange} rows="6" />
                        <label>Methodology</label>
                        <textarea name="methodology" value={editableProject.methodology} onChange={handleInputChange} rows="4" />
                        <label>Tags (comma-separated)</label>
                        <input name="tags" value={editableProject.tags} onChange={handleInputChange} />
                        <div className="edit-actions">
                            <button onClick={handleUpdateProject} className="button-primary" disabled={isSaving}>
                                {isSaving ? <><Loader size={16} className="animate-spin"/> Saving...</> : <><Save size={16}/> Save Changes</>}
                            </button>
                            <button onClick={() => setIsEditing(false)} className="button-secondary"><XCircle size={16}/> Cancel</button>
                        </div>
                    </div>
                ) : (
                    <div className="project-content">
                        <div className="content-section"><h3><FileText size={18}/> Description</h3><p>{project.description}</p></div>
                        <div className="content-section"><h3><TestTube2 size={18}/> Methodology</h3><p>{project.methodology}</p></div>
                        <div className="content-section"><h3><Code size={18}/> Tags</h3><div className="tag-container">{(project.tags || []).map(tag => <Badge key={tag}>{tag}</Badge>)}</div></div>
                        {project.notebook_content && <div className="content-section"><h3>Notebook Preview</h3><JupyterNotebookContentViewer notebookJson={project.notebook_content} /></div>}
                    </div>
                )}
            </div>
        </>
    );
};

const EditProfilePage = ({ user, onNavigate }) => {
    const [profile, setProfile] = useState({ username: '', title: '', bio: '' });
    const [loading, setLoading] = useState(true);
    const [isSaving, setIsSaving] = useState(false);

    useEffect(() => {
        const fetchProfile = async () => {
            setLoading(true);
            const { data, error } = await supabase.from('profiles').select('*').eq('id', user.id).single();
            if (data) {
                setProfile({
                    username: data.username || '',
                    title: data.title || '',
                    bio: data.bio || ''
                });
            } else if (error && error.code !== 'PGRST116') {
                console.error("Error fetching profile:", error);
            }
            setLoading(false);
        };
        fetchProfile();
    }, [user.id]);

    const handleInputChange = (e) => {
        const { name, value } = e.target;
        setProfile(prev => ({ ...prev, [name]: value }));
    };

    const handleUpdateProfile = async (e) => {
        e.preventDefault();
        setIsSaving(true);
        const { error } = await supabase
            .from('profiles')
            .update({
                username: profile.username,
                title: profile.title,
                bio: profile.bio,
                updated_at: new Date()
            })
            .eq('id', user.id);

        if (error) {
            alert('Error updating profile: ' + error.message);
        } else {
            alert('Profile updated successfully!');
            onNavigate('profile', user.id);
        }
        setIsSaving(false);
    };

    if (loading) return <LoadingSpinner />;

    return (
        <>
            <AppHeader onNavigate={onNavigate} user={user} />
            <div className="page-container">
                <button onClick={() => onNavigate('profile', user.id)} className="back-button"><ArrowLeft size={16} /> Back to Profile</button>
                <div className="edit-profile-form">
                    <h2>Edit Your Profile</h2>
                    <form onSubmit={handleUpdateProfile}>
                        <div className="form-group">
                            <label htmlFor="username">Username</label>
                            <input id="username" name="username" value={profile.username} onChange={handleInputChange} placeholder="e.g., dataviz_guru" />
                        </div>
                        <div className="form-group">
                            <label htmlFor="title">Title / Headline</label>
                            <input id="title" name="title" value={profile.title} onChange={handleInputChange} placeholder="e.g., Senior Data Scientist" />
                        </div>
                        <div className="form-group">
                            <label htmlFor="bio">Bio</label>
                            <textarea id="bio" name="bio" value={profile.bio} onChange={handleInputChange} rows="5" placeholder="Tell us about yourself..."/>
                        </div>
                        <div className="edit-actions">
                            <button type="submit" className="button-primary" disabled={isSaving}>
                                {isSaving ? <><Loader size={16} className="animate-spin"/> Saving...</> : <><Save size={16}/> Save Profile</>}
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </>
    );
};

const UserProfilePage = ({ userId, onNavigate, currentUser }) => {
    const [profile, setProfile] = useState(null);
    const [projects, setProjects] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchData = async () => {
            setLoading(true);
            const { data: profileData, error: profileError } = await supabase.from('profiles').select('*').eq('id', userId).single();
            if (profileError) console.error("Profile fetch error:", profileError);
            else setProfile(profileData);
            
            const { data: projectsData, error: projectsError } = await supabase.from('projects').select('*').eq('user_id', userId).order('created_at', { ascending: false });
            if (projectsError) console.error("Projects fetch error:", projectsError);
            else setProjects(projectsData);
            setLoading(false);
        };
        fetchData();
    }, [userId]);

    if (loading) return <LoadingSpinner />;
    if (!profile) return <div>User not found.</div>;

    const isOwner = currentUser.id === userId;

    return (
        <>
            <AppHeader onNavigate={onNavigate} user={currentUser} />
            <div className="page-container">
                <div className="profile-header">
                    <div className="profile-info">
                        <h2>{profile.username || 'Anonymous User'}</h2>
                        <p className="profile-title">{profile.title || 'Data Enthusiast'}</p>
                        <p className="profile-bio">{profile.bio || 'No bio provided.'}</p>
                    </div>
                    {isOwner && <button onClick={() => onNavigate('editProfile')} className="action-button"><Edit size={16}/> Edit Profile</button>}
                </div>
                <div className="profile-content">
                    <h3>Projects</h3>
                    <div className="projects-grid">
                        {projects.length > 0 ? projects.map(p => <ProjectCard key={p.id} project={p} onClick={() => onNavigate('project', p.id)} />) : <p>This user hasn't added any projects yet.</p>}
                    </div>
                </div>
            </div>
        </>
    );
};


// --- Main App Component (Router) ---
export default function App() {
    const [session, setSession] = useState(null);
    const [isAuthLoading, setIsAuthLoading] = useState(true);
    const [authError, setAuthError] = useState('');
    const [view, setView] = useState({ name: 'dashboard', id: null });

    useEffect(() => {
        const getSession = async () => {
            const { data: { session } } = await supabase.auth.getSession();
            setSession(session);
            setIsAuthLoading(false);
        };
        getSession();

        const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
            setSession(session);
        });

        return () => subscription.unsubscribe();
    }, []);

    const handleNavigate = (page, id = null) => {
        setView({ name: page, id });
    };

    let content;

    if (isAuthLoading) {
        content = <LoadingSpinner />;
    } else if (!session) {
        content = <AuthComponent setError={setAuthError} error={authError} />;
    } else {
        switch (view.name) {
            case 'project':
                content = <ProjectDetailPage projectId={view.id} onNavigate={handleNavigate} user={session.user} />;
                break;
            case 'profile':
                content = <UserProfilePage userId={view.id} onNavigate={handleNavigate} currentUser={session.user} />;
                break;
            case 'editProfile':
                content = <EditProfilePage onNavigate={handleNavigate} user={session.user} />;
                break;
            // Add other pages here as needed
            // case 'users':
            //     content = <UserListPage onNavigate={handleNavigate} user={session.user} />;
            //     break;
            default:
                content = <Dashboard user={session.user} onSelectProject={(id) => handleNavigate('project', id)} onNavigate={handleNavigate} />;
                break;
        }
    }

    return (
        <>
            {content}
        </>
    );
}
